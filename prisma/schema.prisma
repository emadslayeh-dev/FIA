generator client {
  provider = "prisma-client-js"
}

datasource db {
  // Start with SQLite locally; switch to Postgres by changing provider + DATABASE_URL
//  provider = "sqlite"
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Company {
  id        String   @id @default(cuid())
  nameHe    String
  nameEn    String?
  imageUrl  String?
  // Business details
  parentName     String?
  country        String?
  region         String?
  city           String?
  postal         String?
  addressLine    String?
  employeesRange String?
  website        String?
  about          String? // Detailed description / vision
  createdAt DateTime @default(now())
  users     User[]
  companyReviews CompanyReview[]
}

model TempRegistration {
  id                String   @id @default(cuid())
  createdAt         DateTime @default(now())
  userType          String
  userTypeOther     String?
  firstName         String
  lastName          String
  email             String
  passwordHash      String?
  companyName       String?
  companySelectedId String?
  noBusiness        Boolean  @default(false)
  country           String?
  department        String?
  role              String?
}

model User {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  firstName     String
  lastName      String
  email         String   @unique
  passwordHash  String
  emailVerifiedAt DateTime?
  userType      String
  userTypeOther String?
  role          String?
  country       String?
  department    String?
  noBusiness    Boolean  @default(false)
  companyId     String?
  company       Company? @relation(fields: [companyId], references: [id])
  // Simple storage for selected categories (CSV of category ids) to keep MVP light
  categoriesCsv String?
  profileImageUrl String?
  description   String?
  verificationTokens VerificationToken[]
  passwordResetTokens PasswordResetToken[]
  receivedReviews Review[]        @relation("ReviewedUser")
  authorReviews   Review[]        @relation("ReviewAuthor")
  authoredCompanyReviews CompanyReview[] @relation("CompanyReviewAuthor")
  // Direct messages relations
  sentMessages     DirectMessage[] @relation("SentMessages")
  receivedMessages DirectMessage[] @relation("ReceivedMessages")
}

model VerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  expiresAt DateTime
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  expiresAt DateTime
  usedAt    DateTime?
}

model Review {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  userId       String
  user         User     @relation("ReviewedUser", fields: [userId], references: [id], onDelete: Cascade)
  authorUserId String
  author       User     @relation("ReviewAuthor", fields: [authorUserId], references: [id])
  rating       Int
  comment      String
}

model CompanyReview {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  companyId    String
  company      Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  authorUserId String
  author       User     @relation("CompanyReviewAuthor", fields: [authorUserId], references: [id])
  rating       Int
  comment      String
}

// Simple direct (one-to-one) messages between two users.
// Threads are derived by grouping on (senderId, recipientId) pairs.
model DirectMessage {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  senderId    String
  recipientId String
  body        String
  readAt      DateTime?
  sender      User     @relation("SentMessages", fields: [senderId], references: [id])
  recipient   User     @relation("ReceivedMessages", fields: [recipientId], references: [id])

  @@index([recipientId, readAt])
  @@index([senderId, recipientId, createdAt])
}
